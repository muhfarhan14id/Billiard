<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Billiard Master Pro - 8 Ball & 9 Ball</title>
    <style>
        /* --- CSS STYLING & RESET --- */
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* Mencegah zoom/scroll default browser */
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: #1a1a1a;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
        }

        /* Container utama game */
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #0d1117;
        }

        /* Canvas rendering */
        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 4px;
            cursor: crosshair;
        }

        /* --- UI OVERLAYS --- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            display: none !important;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            color: #4CAF50;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        h2 {
            font-size: 1.5rem;
            color: #ddd;
            margin-bottom: 20px;
        }

        .coin-display {
            font-size: 1.5rem;
            color: #FFD700;
            margin-bottom: 30px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .btn-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        button {
            background: linear-gradient(145deg, #2c3e50, #273746);
            border: 1px solid #455a64;
            color: white;
            padding: 15px 25px;
            font-size: 1.1rem;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.1s, background 0.2s;
            font-weight: bold;
        }

        button:active {
            transform: scale(0.95);
        }

        button:hover {
            background: #34495e;
            border-color: #4CAF50;
        }

        button.selected {
            background: #4CAF50;
            color: black;
            border-color: #81C784;
        }

        button.play-btn {
            background: linear-gradient(to bottom, #e67e22, #d35400);
            width: 200px;
            font-size: 1.5rem;
            margin-top: 20px;
            border: none;
            box-shadow: 0 4px 0 #a04000;
        }
        
        button.play-btn:active {
            box-shadow: 0 0 0 #a04000;
            transform: translateY(4px);
        }

        /* --- HUD (Heads Up Display) --- */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Klik tembus ke canvas */
            display: none;
        }

        .hud-top {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.6);
            padding: 10px 30px;
            border-radius: 20px;
            display: flex;
            gap: 40px;
            font-size: 1.2rem;
            border: 1px solid #444;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .active-turn {
            color: #4CAF50;
            text-shadow: 0 0 10px #4CAF50;
        }

        .ball-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: inline-block;
            margin-left: 5px;
        }

        #message-area {
            position: absolute;
            top: 20%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 1.5rem;
            color: white;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            text-align: center;
            border: 1px solid white;
        }

        /* --- ROTATION WARNING (Mobile Portrait) --- */
        #rotate-warning {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
        }

        @media screen and (orientation: portrait) {
            #rotate-warning { display: flex; }
        }

    </style>
</head>
<body>

    <!-- Warning untuk rotasi layar -->
    <div id="rotate-warning">
        <h1>Putar Layar Anda</h1>
        <p>Game ini wajib dimainkan dalam mode Landscape.</p>
    </div>

    <div id="game-container">
        <!-- Canvas Utama -->
        <canvas id="poolCanvas"></canvas>

        <!-- HUD (In-Game) -->
        <div id="hud">
            <div class="hud-top">
                <div class="player-info" id="p1-info">
                    <span>PLAYER (Anda)</span>
                    <small id="p1-type">-</small>
                </div>
                <div class="player-info">
                    <span id="bet-info">Bet: 0</span>
                </div>
                <div class="player-info" id="p2-info">
                    <span>BOT AI</span>
                    <small id="p2-type">-</small>
                </div>
            </div>
            <div id="message-area">Pesan Game</div>
        </div>

        <!-- Menu Utama -->
        <div id="main-menu" class="overlay">
            <h1>Billiard Master Pro</h1>
            <div class="coin-display">
                <span>ðŸ’° Saldo:</span>
                <span id="menu-balance">10000</span>
            </div>
            
            <h2>Pilih Mode Permainan</h2>
            <div style="display: flex; gap: 20px; margin-bottom: 20px;">
                <button onclick="selectMode('8ball')" id="btn-8ball" class="selected">8-Ball Pool</button>
                <button onclick="selectMode('9ball')" id="btn-9ball">9-Ball Pool</button>
            </div>

            <h2>Pilih Taruhan</h2>
            <div class="btn-grid">
                <button onclick="selectBet(100)">100</button>
                <button onclick="selectBet(500)">500</button>
                <button onclick="selectBet(2000)">2K</button>
                <button onclick="selectBet(5000)">5K</button>
                <button onclick="selectBet(10000)">10K</button>
                <button onclick="selectBet(20000)">20K</button>
                <button onclick="selectBet(50000)">50K</button>
                <button onclick="selectBet(100000)">100K</button>
            </div>
            
            <button class="play-btn" onclick="startGame()">MAIN</button>
        </div>

        <!-- Menu Game Over -->
        <div id="game-over-menu" class="overlay hidden">
            <h1 id="winner-text">KAMU MENANG!</h1>
            <h2 id="earnings-text">+2000 Koin</h2>
            <button class="play-btn" onclick="returnToMenu()">Menu Utama</button>
        </div>
    </div>

<script>
/**
 * BILLIARD MASTER PRO - SINGLE FILE IMPLEMENTATION
 * Logic Fisika, AI, dan Game Rules
 */

// --- KONFIGURASI GLOBAL ---
const TABLE_RATIO = 2; // Panjang : Lebar (Standard 2:1)
const FRICTION = 0.988; // Koefisien gesekan meja (0-1)
const WALL_BOUNCE = 0.7; // Elastisitas dinding
const BALL_ELASTICITY = 0.95; // Tumbukan antar bola
const MAX_POWER = 35; // Kekuatan maksimum stick
const AI_DELAY = 1500; // Waktu berpikir AI (ms)

// Warna Bola
const BALL_COLORS = [
    '#FFFFFF', // 0 - Cue Ball
    '#E6B422', // 1 - Yellow
    '#0044FF', // 2 - Blue
    '#FF0000', // 3 - Red
    '#800080', // 4 - Purple
    '#FF6600', // 5 - Orange
    '#008000', // 6 - Green
    '#800000', // 7 - Maroon
    '#000000', // 8 - Black
    '#E6B422', // 9 - Yellow Stripe
    '#0044FF', // 10
    '#FF0000', // 11
    '#800080', // 12
    '#FF6600', // 13
    '#008000', // 14
    '#800000'  // 15
];

// --- VARIABEL STATE ---
let canvas, ctx;
let width, height;
let tableRect = {}; // {x, y, w, h}
let balls = [];
let pockets = [];
let rails = [];
let stick = { active: false, angle: 0, power: 0, pulling: false };
let dragStart = { x: 0, y: 0 };

let gameState = {
    mode: '8ball', // '8ball' or '9ball'
    phase: 'MENU', // MENU, PLAYING, GAMEOVER, ANIMATING
    turn: 'PLAYER', // PLAYER, AI
    coins: 10000,
    currentBet: 100,
    ballInHand: false,
    firstHit: null, // Bola pertama yg dipukul frame ini
    pottedBalls: [], // Bola yg masuk frame ini
    assigned: null, // 'SOLIDS' or 'STRIPES' (8-ball only)
    gameOver: false
};

// --- INITIALIZATION ---
window.onload = function() {
    canvas = document.getElementById('poolCanvas');
    ctx = canvas.getContext('2d');
    
    // Resize Event
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    // Input Events
    canvas.addEventListener('mousedown', handleInputStart);
    canvas.addEventListener('mousemove', handleInputMove);
    window.addEventListener('mouseup', handleInputEnd);
    
    canvas.addEventListener('touchstart', (e) => handleInputStart(e.touches[0]));
    canvas.addEventListener('touchmove', (e) => handleInputMove(e.touches[0]));
    window.addEventListener('touchend', handleInputEnd);

    // Load Saldo (jika ada)
    if(localStorage.getItem('billiardCoins')) {
        gameState.coins = parseInt(localStorage.getItem('billiardCoins'));
    }
    updateUI();

    // Start Loop
    requestAnimationFrame(gameLoop);
};

function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    // Hitung area meja (tengah layar)
    let margin = 40;
    let tableW = width - (margin * 2);
    let tableH = tableW / TABLE_RATIO;

    if (tableH > height - (margin * 2)) {
        tableH = height - (margin * 2);
        tableW = tableH * TABLE_RATIO;
    }

    tableRect = {
        x: (width - tableW) / 2,
        y: (height - tableH) / 2,
        w: tableW,
        h: tableH,
        railSize: tableW * 0.025,
        pocketRadius: tableW * 0.035
    };
    
    // Ukuran bola relatif terhadap meja
    Ball.RADIUS = tableRect.w * 0.016; 

    // Definisi Lubang (Pockets)
    let r = tableRect;
    pockets = [
        {x: r.x, y: r.y}, // Top Left
        {x: r.x + r.w/2, y: r.y - r.railSize/2}, // Top Mid
        {x: r.x + r.w, y: r.y}, // Top Right
        {x: r.x, y: r.y + r.h}, // Bot Left
        {x: r.x + r.w/2, y: r.y + r.h + r.railSize/2}, // Bot Mid
        {x: r.x + r.w, y: r.y + r.h} // Bot Right
    ];
}

// --- CLASS DEFINITIONS ---

class Ball {
    static RADIUS = 10;

    constructor(id, x, y) {
        this.id = id; // 0 = cue, 1-7 solids, 8 black, 9-15 stripes
        this.x = x;
        this.y = y;
        this.vx = 0;
        this.vy = 0;
        this.active = true;
        this.inPocket = false;
        
        // Tipe bola
        if (id === 0) this.type = 'CUE';
        else if (id === 8) this.type = 'BLACK';
        else if (id < 8) this.type = 'SOLID';
        else this.type = 'STRIPE';
    }

    update() {
        if (!this.active) return;

        // Apply Velocity
        this.x += this.vx;
        this.y += this.vy;

        // Friction
        this.vx *= FRICTION;
        this.vy *= FRICTION;

        // Stop if too slow
        if (Math.abs(this.vx) < 0.05 && Math.abs(this.vy) < 0.05) {
            this.vx = 0;
            this.vy = 0;
        }

        // Wall Collisions
        // Left
        if (this.x < tableRect.x + tableRect.railSize + Ball.RADIUS) {
            this.x = tableRect.x + tableRect.railSize + Ball.RADIUS;
            this.vx = -this.vx * WALL_BOUNCE;
        }
        // Right
        if (this.x > tableRect.x + tableRect.w - tableRect.railSize - Ball.RADIUS) {
            this.x = tableRect.x + tableRect.w - tableRect.railSize - Ball.RADIUS;
            this.vx = -this.vx * WALL_BOUNCE;
        }
        // Top
        if (this.y < tableRect.y + tableRect.railSize + Ball.RADIUS) {
            this.y = tableRect.y + tableRect.railSize + Ball.RADIUS;
            this.vy = -this.vy * WALL_BOUNCE;
        }
        // Bottom
        if (this.y > tableRect.y + tableRect.h - tableRect.railSize - Ball.RADIUS) {
            this.y = tableRect.y + tableRect.h - tableRect.railSize - Ball.RADIUS;
            this.vy = -this.vy * WALL_BOUNCE;
        }

        // Pocket Detection
        for (let p of pockets) {
            let dx = this.x - p.x;
            let dy = this.y - p.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            
            // Logika masuk lubang agak lenient
            if (dist < tableRect.pocketRadius) {
                this.inPocket = true;
                this.active = false;
                this.vx = 0;
                this.vy = 0;
                return true; // Potted
            }
        }
        return false;
    }

    draw() {
        if (!this.active) return;

        // Bayangan
        ctx.beginPath();
        ctx.arc(this.x + 2, this.y + 2, Ball.RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fill();

        // Badan Bola
        ctx.beginPath();
        ctx.arc(this.x, this.y, Ball.RADIUS, 0, Math.PI * 2);
        ctx.fillStyle = BALL_COLORS[this.id];
        ctx.fill();

        // Stripe putih untuk 9-15
        if (this.id > 8) {
            ctx.beginPath();
            ctx.arc(this.x, this.y, Ball.RADIUS * 0.7, 0, Math.PI * 2);
            ctx.fillStyle = "white";
            ctx.fill(); // Ini membuat bola terlihat seperti bola putih dengan warna di pinggir, simplifikasi visual
            
            // Gambar lagi band warna di tengah untuk stripe
            ctx.beginPath();
            ctx.rect(this.x - Ball.RADIUS, this.y - Ball.RADIUS*0.5, Ball.RADIUS*2, Ball.RADIUS);
            ctx.fillStyle = BALL_COLORS[this.id];
            // Gunakan kliping atau simplifikasi: cukup gambar bola putih, lalu band warna
        }
        
        // Perbaikan rendering bola Stripe yang benar: Putih dasar, warna band
        if (this.id > 8) {
             ctx.beginPath();
             ctx.arc(this.x, this.y, Ball.RADIUS, 0, Math.PI * 2);
             ctx.fillStyle = 'white';
             ctx.fill();
             
             ctx.beginPath();
             ctx.save();
             ctx.arc(this.x, this.y, Ball.RADIUS, 0, Math.PI * 2);
             ctx.clip();
             ctx.fillStyle = BALL_COLORS[this.id];
             ctx.fillRect(this.x - Ball.RADIUS, this.y - Ball.RADIUS/2, Ball.RADIUS*2, Ball.RADIUS);
             ctx.restore();
        }

        // Lingkaran Putih kecil untuk nomor (kecuali cue)
        if (this.id !== 0) {
            ctx.beginPath();
            ctx.fillStyle = "rgba(255,255,255,0.8)";
            ctx.arc(this.x, this.y, Ball.RADIUS * 0.4, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = "black";
            ctx.font = "bold " + (Ball.RADIUS * 0.5) + "px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(this.id, this.x, this.y);
        }
        
        // Highlight/Shine (efek kilap)
        ctx.beginPath();
        ctx.arc(this.x - Ball.RADIUS*0.3, this.y - Ball.RADIUS*0.3, Ball.RADIUS*0.2, 0, Math.PI*2);
        ctx.fillStyle = "rgba(255,255,255,0.3)";
        ctx.fill();
    }
}

// --- GAME LOGIC ---

function selectMode(mode) {
    gameState.mode = mode;
    document.getElementById('btn-8ball').classList.remove('selected');
    document.getElementById('btn-9ball').classList.remove('selected');
    document.getElementById('btn-' + mode).classList.add('selected');
}

function selectBet(amount) {
    if (amount > gameState.coins) {
        alert("Saldo koin tidak cukup!");
        return;
    }
    gameState.currentBet = amount;
    // Highlight tombol bet
    const btns = document.querySelectorAll('.btn-grid button');
    btns.forEach(b => {
        b.classList.remove('selected');
        if (parseInt(b.innerText.replace(/K/g, '000')) === amount || 
            parseInt(b.innerText) === amount) {
            b.classList.add('selected');
        }
    });
}

function updateUI() {
    document.getElementById('menu-balance').innerText = gameState.coins.toLocaleString();
    document.getElementById('bet-info').innerText = "Taruhan: " + gameState.currentBet.toLocaleString();
    
    // Simpan ke localstorage
    localStorage.setItem('billiardCoins', gameState.coins);

    // Update Turn Indicator UI
    const p1Info = document.getElementById('p1-info');
    const p2Info = document.getElementById('p2-info');
    
    if (gameState.turn === 'PLAYER') {
        p1Info.classList.add('active-turn');
        p2Info.classList.remove('active-turn');
    } else {
        p1Info.classList.remove('active-turn');
        p2Info.classList.add('active-turn');
    }

    // Update Assigned Balls (8-Ball)
    if (gameState.mode === '8ball') {
        let type1 = gameState.assigned ? (gameState.assigned === 'SOLIDS' ? 'Solids (1-7)' : 'Stripes (9-15)') : 'Open Table';
        let type2 = gameState.assigned ? (gameState.assigned === 'SOLIDS' ? 'Stripes (9-15)' : 'Solids (1-7)') : 'Open Table';
        document.getElementById('p1-type').innerText = type1;
        document.getElementById('p2-type').innerText = type2;
    } else {
        document.getElementById('p1-type').innerText = "Urutan 1-9";
        document.getElementById('p2-type').innerText = "Urutan 1-9";
    }
}

function showMessage(text) {
    const msg = document.getElementById('message-area');
    msg.innerText = text;
    msg.style.opacity = 1;
    setTimeout(() => {
        msg.style.opacity = 0;
    }, 2000);
}

function startGame() {
    if (gameState.coins < gameState.currentBet) return;
    
    gameState.coins -= gameState.currentBet;
    gameState.phase = 'PLAYING';
    gameState.turn = 'PLAYER';
    gameState.gameOver = false;
    gameState.assigned = null;
    gameState.ballInHand = true; // Break shot bebas taruh cue ball (di area tertentu, tapi disederhanakan: bebas)
    
    document.getElementById('main-menu').classList.add('hidden');
    document.getElementById('hud').style.display = 'block';
    
    setupBalls();
    updateUI();
}

function setupBalls() {
    balls = [];
    
    // Cue Ball
    balls.push(new Ball(0, tableRect.x + tableRect.w * 0.25, tableRect.y + tableRect.h / 2));

    const startX = tableRect.x + tableRect.w * 0.75;
    const startY = tableRect.y + tableRect.h / 2;
    const r = Ball.RADIUS;
    const sep = 1; // Separation margin

    if (gameState.mode === '8ball') {
        // Triangle Formation
        // Row 1
        balls.push(new Ball(1, startX, startY));
        // Row 2
        balls.push(new Ball(9, startX + r*2*Math.sqrt(3)/2 + sep, startY - r - sep));
        balls.push(new Ball(2, startX + r*2*Math.sqrt(3)/2 + sep, startY + r + sep));
        // Row 3 (8 ball in middle)
        balls.push(new Ball(10, startX + r*4*Math.sqrt(3)/2 + sep*2, startY - r*2 - sep*2));
        balls.push(new Ball(8, startX + r*4*Math.sqrt(3)/2 + sep*2, startY));
        balls.push(new Ball(3, startX + r*4*Math.sqrt(3)/2 + sep*2, startY + r*2 + sep*2));
        // Row 4
        balls.push(new Ball(11, startX + r*6*Math.sqrt(3)/2 + sep*3, startY - r*3 - sep*3));
        balls.push(new Ball(4, startX + r*6*Math.sqrt(3)/2 + sep*3, startY - r - sep));
        balls.push(new Ball(12, startX + r*6*Math.sqrt(3)/2 + sep*3, startY + r + sep));
        balls.push(new Ball(5, startX + r*6*Math.sqrt(3)/2 + sep*3, startY + r*3 + sep*3));
        // Row 5
        balls.push(new Ball(13, startX + r*8*Math.sqrt(3)/2 + sep*4, startY - r*4 - sep*4));
        balls.push(new Ball(6, startX + r*8*Math.sqrt(3)/2 + sep*4, startY - r*2 - sep*2));
        balls.push(new Ball(14, startX + r*8*Math.sqrt(3)/2 + sep*4, startY));
        balls.push(new Ball(7, startX + r*8*Math.sqrt(3)/2 + sep*4, startY + r*2 + sep*2));
        balls.push(new Ball(15, startX + r*8*Math.sqrt(3)/2 + sep*4, startY + r*4 + sep*4));
    } else {
        // 9 Ball Diamond
        // 1 at apex, 9 in middle
        // Row 1
        balls.push(new Ball(1, startX, startY));
        // Row 2
        balls.push(new Ball(2, startX + r*1.8, startY - r));
        balls.push(new Ball(3, startX + r*1.8, startY + r));
        // Row 3
        balls.push(new Ball(4, startX + r*3.6, startY - r*2));
        balls.push(new Ball(9, startX + r*3.6, startY));
        balls.push(new Ball(5, startX + r*3.6, startY + r*2));
        // Row 4
        balls.push(new Ball(6, startX + r*5.4, startY - r));
        balls.push(new Ball(7, startX + r*5.4, startY + r));
        // Row 5
        balls.push(new Ball(8, startX + r*7.2, startY));
    }
}

// --- GAME LOOP & PHYSICS ---

function gameLoop() {
    updatePhysics();
    draw();
    
    // Check if balls stopped moving
    const moving = balls.some(b => b.active && (Math.abs(b.vx) > 0 || Math.abs(b.vy) > 0));
    
    if (gameState.phase === 'ANIMATING' && !moving) {
        handleTurnEnd();
    }
    
    // AI Turn Logic
    if (gameState.phase === 'PLAYING' && gameState.turn === 'AI' && !moving) {
         if (!gameState.aiThinking) {
             gameState.aiThinking = true;
             setTimeout(aiExecuteShot, AI_DELAY);
         }
    }

    requestAnimationFrame(gameLoop);
}

function updatePhysics() {
    // 1. Move balls & Check Wall/Pocket
    balls.forEach(b => {
        if(b.update()) {
            gameState.pottedBalls.push(b);
            if (b.id !== 0) showMessage("Bola " + b.id + " Masuk!");
        }
    });

    // 2. Check Ball-to-Ball Collision
    for (let i = 0; i < balls.length; i++) {
        for (let j = i + 1; j < balls.length; j++) {
            let b1 = balls[i];
            let b2 = balls[j];

            if (!b1.active || !b2.active) continue;

            let dx = b2.x - b1.x;
            let dy = b2.y - b1.y;
            let dist = Math.sqrt(dx*dx + dy*dy);

            if (dist < Ball.RADIUS * 2) {
                // Record first hit
                if (b1.id === 0 && gameState.firstHit === null) gameState.firstHit = b2;
                if (b2.id === 0 && gameState.firstHit === null) gameState.firstHit = b1;

                // Resolve overlap
                let angle = Math.atan2(dy, dx);
                let overlap = (Ball.RADIUS * 2 - dist) / 2;
                b1.x -= overlap * Math.cos(angle);
                b1.y -= overlap * Math.sin(angle);
                b2.x += overlap * Math.cos(angle);
                b2.y += overlap * Math.sin(angle);

                // Elastic Collision
                let normalX = dx / dist;
                let normalY = dy / dist;
                let tanX = -normalY;
                let tanY = normalX;

                let v1n = normalX * b1.vx + normalY * b1.vy;
                let v1t = tanX * b1.vx + tanY * b1.vy;
                let v2n = normalX * b2.vx + normalY * b2.vy;
                let v2t = tanX * b2.vx + tanY * b2.vy;

                // Swap normal velocity
                let temp = v1n;
                v1n = v2n;
                v2n = temp;

                // Damping collision
                v1n *= BALL_ELASTICITY;
                v2n *= BALL_ELASTICITY;

                b1.vx = v1n * normalX + v1t * tanX;
                b1.vy = v1n * normalY + v1t * tanY;
                b2.vx = v2n * normalX + v2t * tanX;
                b2.vy = v2n * normalY + v2t * tanY;
            }
        }
    }
}

// --- INPUT HANDLING ---

function handleInputStart(pos) {
    // Konversi koordinat event ke koordinat canvas
    let rect = canvas.getBoundingClientRect();
    let x = (pos.clientX || pos.x) - rect.left;
    let y = (pos.clientY || pos.y) - rect.top;

    if (gameState.phase !== 'PLAYING' || gameState.turn !== 'PLAYER') return;
    
    // Cek apakah klik pada bola putih untuk ball-in-hand
    if (gameState.ballInHand) {
        let cue = balls[0];
        let dx = x - cue.x;
        let dy = y - cue.y;
        if (Math.sqrt(dx*dx + dy*dy) < Ball.RADIUS * 2) {
             // Sedang memindahkan bola putih
             canvas.style.cursor = "move";
             gameState.movingCue = true;
             return;
        }
    }

    // Start aiming
    stick.active = true;
    stick.pulling = false;
    dragStart.x = x;
    dragStart.y = y;
    
    // Set initial angle based on mouse to cue ball
    let cue = balls[0];
    stick.angle = Math.atan2(y - cue.y, x - cue.x);
}

function handleInputMove(pos) {
    let rect = canvas.getBoundingClientRect();
    let x = (pos.clientX || pos.x) - rect.left;
    let y = (pos.clientY || pos.y) - rect.top;
    let cue = balls[0];

    // Ball in hand logic
    if (gameState.ballInHand && gameState.movingCue) {
        // Clamp ke area meja
        x = Math.max(tableRect.x + tableRect.railSize + Ball.RADIUS, Math.min(x, tableRect.x + tableRect.w - tableRect.railSize - Ball.RADIUS));
        y = Math.max(tableRect.y + tableRect.railSize + Ball.RADIUS, Math.min(y, tableRect.y + tableRect.h - tableRect.railSize - Ball.RADIUS));
        cue.x = x;
        cue.y = y;
        return;
    }

    if (!stick.active) return;

    let dx = x - cue.x;
    let dy = y - cue.y;
    let angle = Math.atan2(dy, dx);
    stick.angle = angle;
    
    // Hitung jarak drag untuk power
    let dist = Math.sqrt(dx*dx + dy*dy);
    // Kita asumsikan drag menjauhi bola = power up
    // Atau logic drag backward. Mari gunakan logic drag cue stick:
    // Mouse ada di posisi "gagang", cue ball di ujung.
    // Semakin jauh mouse dari bola, semakin kuat? 
    // Mari gunakan metode "Drag backward to charge" seperti Angry Birds.
    
    // Metode: Klik bola, tarik belakang untuk power.
    // Tapi di sini user drag arah cue. 
    // Mari gunakan: Drag menjauh dari bola untuk membidik dan menentukan power.
    stick.power = Math.min(dist / 5, MAX_POWER);
}

function handleInputEnd() {
    if (gameState.movingCue) {
        gameState.movingCue = false;
        canvas.style.cursor = "default";
        // Ball in hand selesai setelah menembak? Tidak, biasanya boleh dipindah sampai menembak.
        // Tapi untuk simplifikasi kontrol, setelah diletakkan, klik berikutnya adalah aim.
        // Kita biarkan saja.
        return;
    }

    if (stick.active) {
        // SHOOT!
        let cue = balls[0];
        // Power scaling
        let power = stick.power;
        
        if (power > 1) {
            // Invert angle karena kita menarik stick ke belakang, bola maju ke depan
            // Atau jika mouse adalah penunjuk arah tembakan:
            // Jika mouse di depan bola, bola ke arah mouse.
            // Power ditentukan jarak.
            // Kode di atas (atan2) membuat stick menunjuk ke mouse.
            // Jadi bola harus bergerak ke arah mouse.
            
            // Logic stick.angle menunjuk ke arah mouse. 
            // Jadi vx, vy searah angle.
            let shootAngle = stick.angle; // Menembak ke arah mouse
            // Tapi stick visualnya harus dibelakang bola.
            
            cue.vx = Math.cos(shootAngle) * power;
            cue.vy = Math.sin(shootAngle) * power;
            
            gameState.phase = 'ANIMATING';
            gameState.ballInHand = false; // Shot taken
            gameState.pottedBalls = [];
            gameState.firstHit = null;
        }

        stick.active = false;
        stick.power = 0;
    }
}


// --- RULES & TURN MANAGEMENT ---

function handleTurnEnd() {
    gameState.phase = 'PLAYING';
    gameState.aiThinking = false;
    
    let cue = balls[0];
    let foul = false;
    let turnContinues = false;
    let foulMessage = "";

    // 1. Cek Foul Cue Ball Masuk
    if (!cue.active) {
        foul = true;
        foulMessage = "Cue Ball Masuk!";
        // Respawn Cue Ball
        cue.active = true;
        cue.inPocket = false;
        cue.vx = 0; cue.vy = 0;
        cue.x = tableRect.x + tableRect.w * 0.25;
        cue.y = tableRect.y + tableRect.h / 2;
        // Cek overlap
        while(isOverlapping(cue)) {
            cue.x += 10;
        }
        gameState.ballInHand = true;
    }

    // 2. Cek First Hit (Foul jika tidak kena apapun)
    if (!foul && gameState.firstHit === null) {
        foul = true;
        foulMessage = "Tidak Kena Bola!";
        gameState.ballInHand = true;
    }

    // --- RULE LOGIC 8-BALL ---
    if (gameState.mode === '8ball') {
        // Cek 8 Ball
        let black = balls.find(b => b.id === 8);
        if (!black.active) {
            // Game Over Condition
            // Menang jika bola sendiri habis DAN tidak foul saat masukin 8
            // Kalah jika bola sendiri masih ada ATAU foul (cue masuk juga)
            
            let myType = gameState.turn === 'PLAYER' ? 
                (gameState.assigned === 'SOLIDS' ? 'SOLID' : (gameState.assigned === 'STRIPES' ? 'STRIPE' : null)) :
                (gameState.assigned === 'SOLIDS' ? 'STRIPE' : (gameState.assigned === 'STRIPES' ? 'SOLID' : null));
            
            // Hitung sisa bola tipe pemain ini
            let remaining = balls.filter(b => b.active && b.type === myType).length;
            
            if (foul) {
                endGame(gameState.turn === 'PLAYER' ? 'BOT' : 'PLAYER', "Foul saat memasukkan Hitam!");
                return;
            } else if (remaining > 0 && myType !== null) {
                endGame(gameState.turn === 'PLAYER' ? 'BOT' : 'PLAYER', "Memasukkan Hitam terlalu awal!");
                return;
            } else {
                endGame(gameState.turn, "Perfect Win!");
                return;
            }
        }

        // Assignment & Valid Pockets
        if (!foul) {
            // Filter bola yg masuk (selain cue/0)
            let validPots = gameState.pottedBalls.filter(b => b.id !== 0);
            
            if (validPots.length > 0) {
                // Table Open Logic
                if (gameState.assigned === null && validPots.length > 0 && validPots[0].id !== 8) {
                    let firstPot = validPots[0];
                    if (gameState.turn === 'PLAYER') {
                        gameState.assigned = firstPot.type === 'SOLID' ? 'SOLIDS' : 'STRIPES';
                        showMessage("Anda memegang " + gameState.assigned);
                    } else {
                        gameState.assigned = firstPot.type === 'SOLID' ? 'STRIPES' : 'SOLIDS';
                        showMessage("Bot memegang " + (firstPot.type === 'SOLID' ? 'SOLIDS' : 'STRIPES'));
                    }
                }
                
                // Cek apakah bola yang masuk adalah bola milik penembak
                let currentType = gameState.turn === 'PLAYER' ? 
                    (gameState.assigned === 'SOLIDS' ? 'SOLID' : 'STRIPE') :
                    (gameState.assigned === 'SOLIDS' ? 'STRIPE' : 'SOLID');
                
                // Jika table open, turn continues (karena baru assign). 
                // Jika assigned, harus bola yg benar.
                if (gameState.assigned === null) {
                     turnContinues = true;
                } else {
                    let correctBallPotted = validPots.some(b => b.type === currentType);
                    let wrongBallPotted = validPots.some(b => b.type !== currentType && b.id !== 8);
                    
                    if (correctBallPotted && !wrongBallPotted) {
                        turnContinues = true;
                    } else if (wrongBallPotted && !correctBallPotted) {
                        turnContinues = false; // Masuk bola lawan -> ganti giliran
                        showMessage("Bola Lawan Masuk!");
                    } else {
                         // Campur atau logic lain, sederhanakan: jika masuk bola sendiri, lanjut.
                         if (correctBallPotted) turnContinues = true;
                    }
                }

                // Cek First Hit Validity
                let targetType = gameState.turn === 'PLAYER' ? 
                    (gameState.assigned === 'SOLIDS' ? 'SOLID' : 'STRIPE') :
                    (gameState.assigned === 'SOLIDS' ? 'STRIPE' : 'SOLID');
                
                if (gameState.assigned !== null && gameState.firstHit.type !== targetType && gameState.firstHit.id !== 8) {
                    foul = true;
                    foulMessage = "Salah Bola Target!";
                    turnContinues = false;
                    gameState.ballInHand = true;
                }
            }
        }
    }
    
    // --- RULE LOGIC 9-BALL ---
    else if (gameState.mode === '9ball') {
        // Cari bola terendah di meja
        let activeBalls = balls.filter(b => b.active && b.id !== 0).sort((a,b) => a.id - b.id);
        let lowestBall = activeBalls[0];
        
        // Win Condition: 9 Ball masuk
        let nineBall = gameState.pottedBalls.find(b => b.id === 9);
        if (nineBall) {
            if (!foul) {
                endGame(gameState.turn, "9-Ball Potted!");
                return;
            } else {
                // 9-Ball masuk tapi foul (misal cue masuk juga), 9-ball respawn (spot)
                nineBall.active = true;
                nineBall.inPocket = false;
                nineBall.vx = 0; nineBall.vy = 0;
                nineBall.x = tableRect.x + tableRect.w * 0.75;
                nineBall.y = tableRect.y + tableRect.h / 2;
                while(isOverlapping(nineBall)) nineBall.x += 5;
                showMessage("Foul! 9-Ball Respawn.");
            }
        }

        if (!foul) {
            // Rule: First hit harus lowest ball
            if (gameState.firstHit.id !== lowestBall.id) {
                foul = true;
                foulMessage = "Harus kena bola " + lowestBall.id + " dulu!";
                gameState.ballInHand = true;
            } else {
                // Jika bola masuk apa saja (sah), lanjut giliran
                if (gameState.pottedBalls.filter(b => b.id !== 0).length > 0) {
                    turnContinues = true;
                }
            }
        }
    }

    // Finalisasi Ganti Giliran
    if (foul) {
        showMessage("FOUL: " + foulMessage);
        gameState.turn = gameState.turn === 'PLAYER' ? 'AI' : 'PLAYER';
    } else if (!turnContinues) {
        gameState.turn = gameState.turn === 'PLAYER' ? 'AI' : 'PLAYER';
    } else {
        showMessage("Lanjut Jalan...");
    }

    updateUI();
}

function isOverlapping(ball) {
    for (let b of balls) {
        if (b === ball || !b.active) continue;
        let dx = b.x - ball.x;
        let dy = b.y - ball.y;
        if (Math.sqrt(dx*dx + dy*dy) < Ball.RADIUS * 2) return true;
    }
    return false;
}

function endGame(winner, reason) {
    gameState.phase = 'GAMEOVER';
    gameState.gameOver = true;
    
    const winText = document.getElementById('winner-text');
    const earnText = document.getElementById('earnings-text');
    const menu = document.getElementById('game-over-menu');
    
    menu.classList.remove('hidden');
    
    if (winner === 'PLAYER') {
        winText.innerText = "MENANG!";
        winText.style.color = "#4CAF50";
        let winAmount = gameState.currentBet * 2;
        gameState.coins += winAmount;
        earnText.innerText = "+" + winAmount + " Koin (" + reason + ")";
    } else {
        winText.innerText = "KALAH!";
        winText.style.color = "#F44336";
        earnText.innerText = "- " + gameState.currentBet + " Koin (" + reason + ")";
    }
    updateUI();
}

function returnToMenu() {
    document.getElementById('game-over-menu').classList.add('hidden');
    document.getElementById('hud').style.display = 'none';
    document.getElementById('main-menu').classList.remove('hidden');
    gameState.phase = 'MENU';
}

// --- AI BOT ---

function aiExecuteShot() {
    if (gameState.phase !== 'PLAYING') return;

    let cue = balls[0];
    let validTargets = [];

    // Tentukan target sah
    if (gameState.mode === '8ball') {
        let myType = gameState.assigned === 'SOLIDS' ? 'STRIPE' : (gameState.assigned === 'STRIPES' ? 'SOLID' : null);
        
        // Jika AI belum punya tipe (open table) atau tipe null, bisa tembak apa aja kecuali hitam
        if (gameState.assigned === null) {
            validTargets = balls.filter(b => b.active && b.id !== 0 && b.id !== 8);
        } else {
            validTargets = balls.filter(b => b.active && b.type === myType);
        }
        
        // Jika target habis, tembak 8
        if (validTargets.length === 0) {
            validTargets = balls.filter(b => b.active && b.id === 8);
        }
    } else { // 9 Ball
         let activeBalls = balls.filter(b => b.active && b.id !== 0).sort((a,b) => a.id - b.id);
         if(activeBalls.length > 0) validTargets = [activeBalls[0]];
    }

    if (validTargets.length === 0) return; // Should not happen unless gameover logic fails

    // Cari target terbaik (paling dekat dengan lubang)
    let bestShot = null;
    let minDiff = 99999;

    // Ball-in-hand AI logic
    if (gameState.ballInHand) {
        // AI taruh cue ball di posisi enak untuk nembak target pertama
        // Sederhana: taruh segaris lurus ke lubang terdekat dari target
        let target = validTargets[0];
        let bestPocket = pockets[0];
        let minDist = 9999;
        
        pockets.forEach(p => {
             let d = Math.sqrt((target.x-p.x)**2 + (target.y-p.y)**2);
             if(d < minDist) { minDist = d; bestPocket = p; }
        });
        
        // Taruh cue ball sejauh 150px dari target arah berlawanan lubang
        let angleP = Math.atan2(bestPocket.y - target.y, bestPocket.x - target.x);
        cue.x = target.x - Math.cos(angleP) * 150;
        cue.y = target.y - Math.sin(angleP) * 150;
        
        // Clamp
        cue.x = Math.max(tableRect.x + 30, Math.min(cue.x, tableRect.x + tableRect.w - 30));
        cue.y = Math.max(tableRect.y + 30, Math.min(cue.y, tableRect.y + tableRect.h - 30));
        
        gameState.ballInHand = false;
    }

    // Evaluasi tembakan
    validTargets.forEach(target => {
        pockets.forEach(pocket => {
            // Vector Target ke Pocket
            let dxTp = pocket.x - target.x;
            let dyTp = pocket.y - target.y;
            let angleTp = Math.atan2(dyTp, dxTp); // Arah target harus jalan

            // Posisi hantu (Ghost Ball) agar target jalan ke arah pocket
            // Ghost ball harus di belakang target sejauh 2*Radius pada angleTp kebalikannya
            let ghostX = target.x - Math.cos(angleTp) * (Ball.RADIUS * 2);
            let ghostY = target.y - Math.sin(angleTp) * (Ball.RADIUS * 2);

            // Vector Cue ke Ghost
            let dxCg = ghostX - cue.x;
            let dyCg = ghostY - cue.y;
            let distCg = Math.sqrt(dxCg*dxCg + dyCg*dyCg);
            let angleShot = Math.atan2(dyCg, dxCg);

            // Cek apakah jalur bersih (Simplified: cek angle saja)
            // Score berdasarkan jarak dan kelurusan
            // Angle diff antara shot line dan target line
            let angleDiff = Math.abs(angleShot - angleTp);
            // Normalize angle diff
            while(angleDiff > Math.PI) angleDiff -= Math.PI*2;
            angleDiff = Math.abs(angleDiff);

            if (distCg < minDiff) {
                minDiff = distCg;
                bestShot = { angle: angleShot, dist: distCg };
            }
        });
    });

    if (bestShot) {
        // Tambah human error (randomness)
        let error = (Math.random() - 0.5) * 0.05; // +/- deviation
        let finalAngle = bestShot.angle + error;
        
        // Power berdasarkan jarak
        let power = Math.min(bestShot.dist / 10 + 15, MAX_POWER);
        
        cue.vx = Math.cos(finalAngle) * power;
        cue.vy = Math.sin(finalAngle) * power;

        gameState.phase = 'ANIMATING';
        gameState.pottedBalls = [];
        gameState.firstHit = null;
    }
}

// --- RENDERING ---

function draw() {
    // 1. Draw Background & Table
    ctx.fillStyle = "#333";
    ctx.fillRect(0, 0, width, height);

    // Kayu Meja
    ctx.fillStyle = "#5D4037";
    ctx.fillRect(tableRect.x - 20, tableRect.y - 20, tableRect.w + 40, tableRect.h + 40);

    // Kain Meja (Felt)
    ctx.fillStyle = "#2E7D32"; // Standard Green
    ctx.fillRect(tableRect.x, tableRect.y, tableRect.w, tableRect.h);
    
    // Grid/Lines
    ctx.strokeStyle = "rgba(255,255,255,0.1)";
    ctx.lineWidth = 2;
    // Head string
    ctx.beginPath();
    ctx.moveTo(tableRect.x + tableRect.w * 0.25, tableRect.y);
    ctx.lineTo(tableRect.x + tableRect.w * 0.25, tableRect.y + tableRect.h);
    ctx.stroke();

    // Rails (Bantalan)
    ctx.fillStyle = "#1B5E20";
    // Top
    ctx.fillRect(tableRect.x, tableRect.y, tableRect.w, tableRect.railSize);
    // Bottom
    ctx.fillRect(tableRect.x, tableRect.y + tableRect.h - tableRect.railSize, tableRect.w, tableRect.railSize);
    // Left
    ctx.fillRect(tableRect.x, tableRect.y, tableRect.railSize, tableRect.h);
    // Right
    ctx.fillRect(tableRect.x + tableRect.w - tableRect.railSize, tableRect.y, tableRect.railSize, tableRect.h);

    // Pockets
    ctx.fillStyle = "#000";
    for (let p of pockets) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, tableRect.pocketRadius, 0, Math.PI * 2);
        ctx.fill();
        // Highlight metal
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 2;
        ctx.stroke();
    }

    // 2. Draw Balls
    balls.forEach(b => b.draw());

    // 3. Draw Stick & Aim Guideline (Only Player Turn & Static)
    if (gameState.phase === 'PLAYING' && gameState.turn === 'PLAYER' && stick.active) {
        let cue = balls[0];
        
        // Aim Line
        ctx.beginPath();
        ctx.moveTo(cue.x, cue.y);
        // Garis bidik searah mouse (stick.angle)
        // Panjang garis visual
        let guideLen = 500;
        let endX = cue.x + Math.cos(stick.angle) * guideLen;
        let endY = cue.y + Math.sin(stick.angle) * guideLen;
        
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 2;
        ctx.lineTo(endX, endY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Stick Graphic
        // Stick digambar di sisi berlawanan arah tembak
        // Jarak stick dari bola (offset animasi pukulan)
        let offset = 20 + stick.power * 2; 
        
        ctx.save();
        ctx.translate(cue.x, cue.y);
        ctx.rotate(stick.angle + Math.PI); // Putar 180 derajat agar di belakang
        
        // Stick Body
        ctx.fillStyle = "#D2691E"; // Wood color
        ctx.fillRect(offset, -4, 300, 8);
        
        // Stick Tip
        ctx.fillStyle = "#FFF";
        ctx.fillRect(offset - 5, -4, 5, 8);
        ctx.fillStyle = "#00F"; // Chalk
        ctx.fillRect(offset - 7, -4, 2, 8);
        
        ctx.restore();

        // Power Bar
        let pPct = stick.power / MAX_POWER;
        let barW = 200;
        let barH = 20;
        let bx = (width - barW) / 2;
        let by = height - 50;

        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(bx, by, barW, barH);
        
        // Gradient Power
        let grad = ctx.createLinearGradient(bx, 0, bx + barW, 0);
        grad.addColorStop(0, "yellow");
        grad.addColorStop(1, "red");
        
        ctx.fillStyle = grad;
        ctx.fillRect(bx + 2, by + 2, (barW - 4) * pPct, barH - 4);
        
        ctx.strokeStyle = "white";
        ctx.strokeRect(bx, by, barW, barH);
        
        ctx.fillStyle = "white";
        ctx.font = "14px Arial";
        ctx.fillText("POWER", bx + barW/2, by - 5);
    }
    
    // Ball In Hand Indicator
    if (gameState.ballInHand && gameState.turn === 'PLAYER') {
        ctx.fillStyle = "white";
        ctx.font = "20px Arial";
        ctx.fillText("BALL IN HAND - Geser Bola Putih", width/2, 50);
    }
}

</script>
</body>
  </html>
