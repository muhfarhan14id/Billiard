<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Master Billiard Pro - 8 Ball & 9 Ball</title>
    <style>
        /* --- CSS: RESET & VIEWPORT HANDLING --- */
        :root {
            --primary: #ffcc00;
            --bg-dark: #1a1a1a;
            --glass: rgba(255, 255, 255, 0.1);
            --ui-font: 'Segoe UI', Roboto, sans-serif;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }
        
        body, html {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background-color: #000;
            overflow: hidden;
            font-family: var(--ui-font);
            color: white;
        }

        /* Container utama game yang menyesuaikan dengan Safe Area & Visual Viewport */
        #game-container {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #111;
        }

        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 4px;
        }

        /* --- UI OVERLAYS --- */
        .ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Biarkan klik tembus ke canvas kecuali elemen interaktif */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }

        .interactive { pointer-events: auto; }

        /* HUD Atas */
        .top-hud {
            display: flex;
            justify-content: space-between;
            padding: 10px 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .player-card {
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.5);
            padding: 5px 15px;
            border-radius: 20px;
            border: 1px solid #444;
        }

        .avatar { width: 30px; height: 30px; border-radius: 50%; background: #ddd; border: 2px solid white; }
        .active-turn { border-color: var(--primary); box-shadow: 0 0 10px var(--primary); }

        /* Spin Control */
        #spin-control {
            position: absolute;
            top: 60px; right: 20px;
            width: 80px; height: 80px;
            background: rgba(255,255,255,0.9);
            border-radius: 50%;
            border: 4px solid #333;
        }
        #spin-dot {
            width: 10px; height: 10px; background: red; border-radius: 50%;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        /* Tombol Cheat / Toggle */
        .tools-panel {
            position: absolute;
            bottom: 20px; right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .btn-tool {
            background: rgba(0,0,0,0.7);
            color: white; border: 1px solid #555;
            padding: 8px 12px; border-radius: 8px;
            font-size: 12px; cursor: pointer;
        }
        .btn-tool.active { background: var(--primary); color: black; font-weight: bold; }

        /* --- MAIN MENU --- */
        #main-menu {
            position: absolute; inset: 0;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><rect fill="%231a1a1a" width="100" height="100"/><circle cx="50" cy="50" r="2" fill="%23222"/></svg>');
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100;
            transition: opacity 0.3s;
        }

        .logo { font-size: 3rem; font-weight: 900; color: var(--primary); text-shadow: 0 4px 10px rgba(0,0,0,0.5); margin-bottom: 10px; }
        .balance-display { background: #333; padding: 10px 20px; border-radius: 30px; border: 2px solid gold; margin-bottom: 30px; font-weight: bold; color: gold; font-size: 1.2rem; }

        .room-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            max-width: 600px;
            width: 90%;
        }

        .room-card {
            background: linear-gradient(145deg, #2a2a2a, #1f1f1f);
            border: 1px solid #444;
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .room-card:active { transform: scale(0.95); }
        .bet-amount { font-size: 1.5rem; font-weight: bold; color: white; display: block; margin-bottom: 5px; }
        .mode-select { margin-bottom: 20px; display: flex; gap: 10px; }
        .mode-btn { padding: 10px 20px; background: #333; border: 1px solid #555; color: #888; border-radius: 20px; cursor: pointer; }
        .mode-btn.selected { background: var(--primary); color: black; font-weight: bold; }

        /* Modal Result */
        #result-modal {
            display: none; position: absolute; inset: 0; background: rgba(0,0,0,0.85);
            z-index: 200; align-items: center; justify-content: center; flex-direction: column;
        }
        .result-title { font-size: 3rem; font-weight: bold; margin-bottom: 20px; }
        .win { color: var(--primary); }
        .lose { color: #ff4444; }
        .btn-main { background: var(--primary); color: black; padding: 15px 40px; border-radius: 30px; font-weight: bold; border: none; font-size: 1.2rem; cursor: pointer; }

        /* Power Bar */
        #power-container {
            position: absolute; left: 20px; top: 50%; transform: translateY(-50%);
            width: 30px; height: 200px; background: rgba(0,0,0,0.6);
            border: 2px solid #555; border-radius: 15px; overflow: hidden;
            display: none; /* Show only in game */
        }
        #power-fill {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 0%;
            background: linear-gradient(to top, lime, yellow, red);
            transition: height 0.1s linear;
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <!-- CONTAINER UTAMA -->
    <div id="game-container">
        <canvas id="poolCanvas"></canvas>
    </div>

    <!-- UI GAMEPLAY -->
    <div id="game-ui" class="ui-layer hidden">
        <div class="top-hud">
            <div class="player-card" id="p1-card">
                <div class="avatar"></div>
                <div id="p1-name">Player</div>
                <div id="p1-type" style="font-size: 0.8em; color: #aaa;">(Solid)</div>
            </div>
            <div style="background:rgba(0,0,0,0.6); padding:5px 10px; border-radius:10px; color: gold; font-weight:bold;">
                Pot: <span id="pot-amount">0</span>
            </div>
            <div class="player-card" id="p2-card">
                <div class="avatar" style="background:#555"></div>
                <div id="p2-name">AI Bot</div>
                <div id="p2-type" style="font-size: 0.8em; color: #aaa;">(Stripe)</div>
            </div>
        </div>

        <!-- Spin Controller -->
        <div id="spin-control" class="interactive">
            <div id="spin-dot"></div>
            <div style="position: absolute; bottom: -20px; width: 100%; text-align: center; font-size: 10px; font-weight: bold; color: white;">SPIN</div>
        </div>

        <!-- Power Bar (Visual) -->
        <div id="power-container">
            <div id="power-fill"></div>
        </div>

        <!-- Tools / Cheats -->
        <div class="tools-panel interactive">
            <button class="btn-tool" onclick="game.toggleGuideline()">Extend Guide</button>
            <button class="btn-tool" onclick="game.toggleCheto()">Cheto Mode</button>
            <button class="btn-tool" onclick="game.pauseGame()">Menu</button>
        </div>
    </div>

    <!-- MAIN MENU -->
    <div id="main-menu">
        <div class="logo">8 BALL <span style="color:white">PRO</span></div>
        <div class="balance-display">Saldo: <span id="user-balance">1000</span></div>
        
        <div class="mode-select interactive">
            <div class="mode-btn selected" onclick="menu.selectMode(8)">8 Ball</div>
            <div class="mode-btn" onclick="menu.selectMode(9)">9 Ball</div>
        </div>

        <div class="room-grid interactive">
            <div class="room-card" onclick="menu.enterRoom(100)">
                <span class="bet-amount">100</span>
                <span style="color:#aaa">Entry Fee</span>
            </div>
            <div class="room-card" onclick="menu.enterRoom(500)">
                <span class="bet-amount">500</span>
                <span style="color:#aaa">Entry Fee</span>
            </div>
            <div class="room-card" onclick="menu.enterRoom(2000)">
                <span class="bet-amount">2K</span>
                <span style="color:#aaa">Entry Fee</span>
            </div>
            <div class="room-card" onclick="menu.enterRoom(10000)">
                <span class="bet-amount">10K</span>
                <span style="color:#aaa">Entry Fee</span>
            </div>
            <div class="room-card" onclick="menu.enterRoom(50000)">
                <span class="bet-amount">50K</span>
                <span style="color:#aaa">High Roller</span>
            </div>
             <div class="room-card" onclick="menu.enterRoom(100000)">
                <span class="bet-amount">100K</span>
                <span style="color:#aaa">Master</span>
            </div>
        </div>
    </div>

    <!-- RESULT MODAL -->
    <div id="result-modal" class="interactive">
        <div class="result-title" id="result-text">YOU WIN!</div>
        <div style="margin-bottom:20px; color:#ccc" id="result-prize">Prize: 200</div>
        <button class="btn-main" onclick="menu.backToMenu()">Main Menu</button>
    </div>

    <script>
        /**
         * ------------------------------------------------------------------
         * ENGINE CONFIGURATION & MATH
         * ------------------------------------------------------------------
         */
        const CONFIG = {
            friction: 0.990, // Rolling friction
            slidingFriction: 0.985, // Before rolling
            railRestitution: 0.6, // Bounciness of rails
            ballRestitution: 0.92, // Bounciness of balls
            pocketRadius: 32, // Adjusted for canvas scale
            ballRadius: 13,
            tableWidth: 800,
            tableHeight: 400,
            maxPower: 45,
            guidelineLength: 200,
            simSteps: 800 // For guideline prediction
        };

        // Math Helpers: Vector2D
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { return new Vector(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
            mult(n) { return new Vector(this.x * n, this.y * n); }
            div(n) { return new Vector(this.x / n, this.y / n); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            dist(v) { return Math.sqrt(Math.pow(this.x - v.x, 2) + Math.pow(this.y - v.y, 2)); }
            normalize() { let m = this.mag(); return m === 0 ? new Vector(0,0) : this.div(m); }
            dot(v) { return this.x * v.x + this.y * v.y; }
            copy() { return new Vector(this.x, this.y); }
            static dist(v1, v2) { return v1.dist(v2); }
        }

        /**
         * ------------------------------------------------------------------
         * GAME CLASSES (Ball, Table)
         * ------------------------------------------------------------------
         */
        class Ball {
            constructor(id, x, y, type) {
                this.id = id;
                this.pos = new Vector(x, y);
                this.vel = new Vector(0, 0);
                this.radius = CONFIG.ballRadius;
                this.type = type; // 0: Cue, 1-7: Solid, 8: Black, 9-15: Stripe
                this.active = true; // On table
                this.potted = false;
                this.color = this.getColor(id);
                this.texture = null; // Can generate canvas texture for efficiency
            }

            getColor(id) {
                if (id === 0) return '#fff';
                if (id === 8) return '#111';
                const colors = ['#eecb02', '#0043ff', '#ff0000', '#6300a8', '#ff6600', '#009900', '#800000'];
                return colors[(id - 1) % 8];
            }

            update() {
                if (!this.active) return;

                // Move
                this.pos = this.pos.add(this.vel);

                // Friction
                if (this.vel.mag() > 0.05) {
                    this.vel = this.vel.mult(CONFIG.friction);
                } else {
                    this.vel = new Vector(0, 0);
                }
            }
        }

        class Table {
            constructor() {
                // Dimensi meja relatif terhadap logical size 800x400
                this.width = CONFIG.tableWidth;
                this.height = CONFIG.tableHeight;
                this.x = 0; // Akan di-center saat render
                this.y = 0;
                
                // Definisi Pocket (TopLeft, TopMid, TopRight, etc.)
                this.pockets = [
                    new Vector(0, 0), new Vector(this.width/2, -10), new Vector(this.width, 0),
                    new Vector(0, this.height), new Vector(this.width/2, this.height+10), new Vector(this.width, this.height)
                ];

                // Rails (batas untuk collision)
                this.rails = {
                    left: 0 + CONFIG.ballRadius,
                    right: this.width - CONFIG.ballRadius,
                    top: 0 + CONFIG.ballRadius,
                    bottom: this.height - CONFIG.ballRadius
                };
            }
        }

        /**
         * ------------------------------------------------------------------
         * PHYSICS ENGINE
         * ------------------------------------------------------------------
         */
        const Physics = {
            checkCollisions: (balls, table, isSimulation = false) => {
                let eventOccurred = false;

                // 1. Ball vs Pocket
                balls.forEach(b => {
                    if (!b.active) return;
                    for (let p of table.pockets) {
                        if (b.pos.dist(p) < CONFIG.pocketRadius) {
                            // Suction effect (sederhana)
                            if (b.pos.dist(p) < CONFIG.pocketRadius * 0.7) {
                                if(!isSimulation) {
                                    b.active = false;
                                    b.potted = true;
                                    b.vel = new Vector(0,0);
                                    game.onBallPotted(b);
                                } else {
                                    // Untuk simulasi, tandai saja berhenti
                                    b.active = false;
                                    b.vel = new Vector(0,0); 
                                }
                                eventOccurred = true;
                            } else {
                                // Gravitasi pocket (tarik sedikit)
                                let dir = p.sub(b.pos).normalize().mult(0.5);
                                b.vel = b.vel.add(dir);
                            }
                        }
                    }
                });

                // 2. Ball vs Rail
                balls.forEach(b => {
                    if (!b.active) return;
                    let bounced = false;
                    
                    if (b.pos.x < table.rails.left) {
                        b.pos.x = table.rails.left;
                        b.vel.x *= -CONFIG.railRestitution;
                        bounced = true;
                    } else if (b.pos.x > table.rails.right) {
                        b.pos.x = table.rails.right;
                        b.vel.x *= -CONFIG.railRestitution;
                        bounced = true;
                    }

                    if (b.pos.y < table.rails.top) {
                        b.pos.y = table.rails.top;
                        b.vel.y *= -CONFIG.railRestitution;
                        bounced = true;
                    } else if (b.pos.y > table.rails.bottom) {
                        b.pos.y = table.rails.bottom;
                        b.vel.y *= -CONFIG.railRestitution;
                        bounced = true;
                    }

                    if(bounced && !isSimulation) {
                         // Apply Spin Effect on Rail (English)
                         // Jika ada side spin, pantulan miring sedikit (Throw Effect)
                         let spinX = game.spinOffset.x; // -1 to 1
                         if (Math.abs(spinX) > 0.1) {
                             // Putar vektor velocity sedikit berdasarkan spin
                             // Math.cos/sin rotasi
                             let angle = spinX * 0.1; // Max 0.1 radian deflection
                             let ca = Math.cos(angle);
                             let sa = Math.sin(angle);
                             let newVx = b.vel.x * ca - b.vel.y * sa;
                             let newVy = b.vel.x * sa + b.vel.y * ca;
                             b.vel.x = newVx;
                             b.vel.y = newVy;
                         }
                         if(!game.soundPlayed) { /* Play rail sound */ game.soundPlayed = true; } // Debounce
                    }
                });

                // 3. Ball vs Ball
                for (let i = 0; i < balls.length; i++) {
                    for (let j = i + 1; j < balls.length; j++) {
                        let b1 = balls[i];
                        let b2 = balls[j];
                        if (!b1.active || !b2.active) continue;

                        let dist = b1.pos.dist(b2.pos);
                        if (dist < b1.radius + b2.radius) {
                            // Collision detected
                            
                            // 1. Resolve Overlap (static resolution)
                            let overlap = (b1.radius + b2.radius - dist) / 2;
                            let n = b2.pos.sub(b1.pos).normalize();
                            b1.pos = b1.pos.sub(n.mult(overlap));
                            b2.pos = b2.pos.add(n.mult(overlap));

                            // 2. Resolve Velocity (Dynamic)
                            // Normal
                            let un = n;
                            // Tangent
                            let ut = new Vector(-un.y, un.x);

                            // Project velocities onto normal and tangent
                            let v1n = un.dot(b1.vel);
                            let v1t = ut.dot(b1.vel);
                            let v2n = un.dot(b2.vel);
                            let v2t = ut.dot(b2.vel);

                            // 1D elastic collision on normal
                            let v1nTag = (v1n * (b1.radius - b2.radius) + 2 * b2.radius * v2n) / (b1.radius + b2.radius);
                            let v2nTag = (v2n * (b2.radius - b1.radius) + 2 * b1.radius * v1n) / (b1.radius + b2.radius);

                            // Convert scalar normal and tangent velocities into vectors
                            let v1nTagV = un.mult(v1nTag);
                            let v1tTagV = ut.mult(v1t);
                            let v2nTagV = un.mult(v2nTag);
                            let v2tTagV = ut.mult(v2t);

                            // Update velocities with Restitution
                            b1.vel = v1nTagV.add(v1tTagV).mult(CONFIG.ballRestitution);
                            b2.vel = v2nTagV.add(v2tTagV).mult(CONFIG.ballRestitution);

                            eventOccurred = true;

                            if (!isSimulation) {
                                game.onBallCollision(b1, b2);
                            }
                        }
                    }
                }
                return eventOccurred;
            }
        };

        /**
         * ------------------------------------------------------------------
         * AI (ARTIFICIAL INTELLIGENCE)
         * ------------------------------------------------------------------
         * Evaluasi Shot Terbaik berdasarkan Raycasting & Probabilitas
         */
        const AI = {
            state: 'idle', // thinking, shooting
            thinkTime: 0,

            decideShot: () => {
                const legalBalls = game.getLegalBalls(game.turn);
                let bestShot = { score: -9999, angle: 0, power: 0 };
                const cue = game.balls[0];

                if (legalBalls.length === 0) {
                     // Free ball or weird state, shoot random safe
                     return { angle: Math.random() * Math.PI * 2, power: 15 };
                }

                // Loop setiap bola legal
                legalBalls.forEach(target => {
                    // Loop setiap pocket
                    game.table.pockets.forEach(pocket => {
                        // Vector target -> pocket
                        let pocketVec = pocket.sub(target.pos);
                        let distToPocket = pocketVec.mag();
                        let aimDir = pocketVec.normalize();

                        // Posisi "Ghost Ball" (dimana Cue harus mengenai Target)
                        // Target pos - (aimDir * 2 radii)
                        let ghostPos = target.pos.sub(aimDir.mult(CONFIG.ballRadius * 2));
                        
                        // Vector Cue -> Ghost
                        let shotVec = ghostPos.sub(cue.pos);
                        let shotDist = shotVec.mag();
                        let shotDir = shotVec.normalize();
                        let shotAngle = Math.atan2(shotDir.y, shotDir.x);

                        // Validasi 1: Cut Angle (Sudut potong)
                        // Dot product antara shotDir dan aimDir
                        // Jika < 0, berarti menembak mundur (mustahil untuk pot langsung)
                        let cutDot = shotDir.dot(aimDir);
                        if (cutDot < 0.1) return; // Sudut terlalu tipis atau negatif

                        // Validasi 2: Raycast (Apakah jalur bersih?)
                        if (!AI.raycastClear(cue.pos, ghostPos, [cue, target])) return; // Jalur cue ke target terhalang
                        if (!AI.raycastClear(target.pos, pocket, [cue, target])) return; // Jalur target ke pocket terhalang

                        // Hitung Skor
                        let score = 100;
                        score -= distToPocket * 0.1; // Semakin jauh ke lubang, semakin susah
                        score -= shotDist * 0.05;    // Semakin jauh cue ke target, semakin susah
                        score += cutDot * 50;        // Semakin lurus, semakin bagus

                        // Prioritas bola 8/9 jika bisa menang
                        if ((game.gameMode === 8 && target.id === 8) || (game.gameMode === 9 && target.id === 9)) {
                            score += 200;
                        }

                        if (score > bestShot.score) {
                            bestShot = {
                                score: score,
                                angle: shotAngle,
                                power: Math.min(CONFIG.maxPower, distToPocket * 0.05 + shotDist * 0.05 + 15) // Adjust power
                            };
                        }
                    });
                });

                // Jika tidak ada shot langsung yang bagus, tembak bola legal terdekat (Safety play sederhana)
                if (bestShot.score === -9999) {
                    let closest = legalBalls[0];
                    let minD = 9999;
                    legalBalls.forEach(b => {
                        let d = cue.pos.dist(b.pos);
                        if(d < minD) { minD = d; closest = b; }
                    });
                    let angle = Math.atan2(closest.pos.y - cue.pos.y, closest.pos.x - cue.pos.x);
                    bestShot = { angle: angle, power: 15 };
                }

                // Tambahkan sedikit "Human Noise" agar tidak 100% robotik setiap saat
                let noise = (Math.random() - 0.5) * 0.02; 
                bestShot.angle += noise;

                return bestShot;
            },

            raycastClear: (start, end, ignoreBalls) => {
                // Sederhana: Cek apakah garis start->end memotong lingkaran bola lain
                // Jarak titik ke garis
                let lineVec = end.sub(start);
                let lineLen = lineVec.mag();
                let dir = lineVec.normalize();

                for (let b of game.balls) {
                    if (!b.active) continue;
                    if (ignoreBalls.includes(b)) continue;

                    // Proyeksi pusat bola ke garis
                    let toBall = b.pos.sub(start);
                    let projection = toBall.dot(dir);

                    if (projection > 0 && projection < lineLen) {
                        // Titik terdekat pada garis
                        let closestPoint = start.add(dir.mult(projection));
                        let dist = closestPoint.dist(b.pos);
                        if (dist < CONFIG.ballRadius * 2) { // 2 radius lebar jalur
                            return false; // Terhalang
                        }
                    }
                }
                return true;
            }
        };

        /**
         * ------------------------------------------------------------------
         * GAME LOGIC & STATE MANAGEMENT
         * ------------------------------------------------------------------
         */
        const game = {
            canvas: null,
            ctx: null,
            width: 0,
            height: 0,
            scale: 1, // Canvas scaling for high DPI

            state: 'MENU', // MENU, IDLE (Aiming), MOVING, END
            gameMode: 8, // 8 or 9
            balls: [],
            table: null,
            
            // Player Info
            turn: 0, // 0: Human, 1: AI
            assignedGroups: { 0: null, 1: null }, // 'solid' or 'stripe'
            pottedThisTurn: [],
            foul: false,
            ballInHand: false,

            // Controls
            cueAngle: 0,
            cuePower: 0,
            isDragging: false,
            spinOffset: new Vector(0,0), // x: side, y: top/back (-1 to 1)

            // Settings
            chetoMode: false,
            extendGuide: false,
            soundPlayed: false,

            init: () => {
                game.canvas = document.getElementById('poolCanvas');
                game.ctx = game.canvas.getContext('2d');
                game.table = new Table();
                
                Input.init();
                game.resize();
                
                // Start Loop
                requestAnimationFrame(game.loop);

                // Load Balance
                const saved = localStorage.getItem('billiard_balance');
                if (saved) menu.balance = parseInt(saved);
                menu.updateUI();
            },

            resize: () => {
                // Handling Viewport Mobile (The "Android Fix")
                // Menggunakan visualViewport width/height jika tersedia untuk akurasi saat keyboard/browser bar muncul
                const vw = window.visualViewport ? window.visualViewport.width : window.innerWidth;
                const vh = window.visualViewport ? window.visualViewport.height : window.innerHeight;

                game.width = vw;
                game.height = vh;
                
                game.canvas.width = game.width;
                game.canvas.height = game.height;

                // Scale logic: Fit table into screen with margin
                // Table logical size: 800x400
                // Margin: 20px
                let targetW = game.width - 40;
                let targetH = game.height - 40;
                
                let scaleW = targetW / CONFIG.tableWidth;
                let scaleH = targetH / CONFIG.tableHeight;
                
                // Keep aspect ratio
                game.scale = Math.min(scaleW, scaleH);
                
                // Center table
                game.table.x = (game.width - CONFIG.tableWidth * game.scale) / 2;
                game.table.y = (game.height - CONFIG.tableHeight * game.scale) / 2;
            },

            setupRack: (mode) => {
                game.balls = [];
                // Cue Ball
                game.balls.push(new Ball(0, CONFIG.tableWidth/4, CONFIG.tableHeight/2, 'cue'));

                // Rack Position
                let startX = CONFIG.tableWidth * 0.75;
                let startY = CONFIG.tableHeight / 2;
                let r = CONFIG.ballRadius;
                
                // Sederhana: Pyramid Setup
                let rows = 5;
                let count = 0;
                
                if (mode === 9) {
                    // Diamond Rack for 9 ball
                    // Simplified diamond structure positions
                    const ninePos = [
                        [0,0], [1,-1], [1,1], [2,-2], [2,0], [2,2], [3,-1], [3,1], [4,0]
                    ];
                    // Map IDs: 1 at front, 9 in middle, others random
                    let ids = [1, 2, 3, 4, 9, 5, 6, 7, 8]; // Just hardcoded layout for stability
                    
                    ninePos.forEach((p, i) => {
                        if (i >= ids.length) return;
                        let x = startX + p[0] * (r * 1.8); // 1.8 slightly tighter pack
                        let y = startY + p[1] * r;
                        game.balls.push(new Ball(ids[i], x, y, ids[i] <= 8 ? 'solid' : 'stripe')); // Type doesn't matter much in 9ball
                    });
                } else {
                    // 8 Ball Triangle
                    let ballIds = [1, 10, 2, 11, 8, 3, 12, 4, 13, 5, 14, 6, 15]; // Pattern for mix
                    let idx = 0;
                    for (let col = 0; col < 5; col++) {
                        for (let row = 0; row <= col; row++) {
                            let x = startX + col * (r * 1.8);
                            let y = startY - (col * r) + (row * r * 2);
                            
                            let id = 0;
                            if (col === 0) id = 1; // Apex
                            else if (col === 2 && row === 1) id = 8; // Middle 8
                            else {
                                if (idx < ballIds.length) id = ballIds[idx++];
                                else id = 7;
                            }
                            
                            let type = (id === 8) ? 'black' : (id < 8 ? 'solid' : 'stripe');
                            game.balls.push(new Ball(id, x, y, type));
                        }
                    }
                }
            },

            startMatch: (mode, bet) => {
                game.gameMode = mode;
                game.setupRack(mode);
                game.turn = 0; // Player starts
                game.state = 'IDLE';
                game.assignedGroups = { 0: null, 1: null };
                game.cueAngle = 0;
                game.foul = false;
                game.ballInHand = true; // Break is ball in hand behind line (simplified to anywhere for UX)
                game.spinOffset = new Vector(0,0);
                
                document.getElementById('main-menu').classList.add('hidden');
                document.getElementById('game-ui').classList.remove('hidden');
                game.updateHUD();
            },

            shoot: () => {
                if (game.state !== 'IDLE') return;
                
                let cue = game.balls[0];
                let force = game.cuePower;
                
                // Konversi Angle & Power ke Velocity Vector
                let vx = Math.cos(game.cueAngle) * force;
                let vy = Math.sin(game.cueAngle) * force;
                
                // Apply Backspin/Topspin effect to initial velocity decay or curve?
                // For simplified engine: We just set velocity. Spin affects physics engine later.
                cue.vel = new Vector(vx, vy);
                
                game.state = 'MOVING';
                game.pottedThisTurn = [];
                game.foul = false;
                game.firstHit = null;
                game.railContactAfterHit = false;
                game.soundPlayed = false;

                // Hide power bar
                document.getElementById('power-container').style.display = 'none';
                document.getElementById('power-fill').style.height = '0%';
            },

            update: () => {
                if (game.state === 'MOVING') {
                    let moving = false;
                    
                    // Sub-steps for better collision stability
                    let steps = 4;
                    for(let s=0; s<steps; s++) {
                        game.balls.forEach(b => b.update());
                        Physics.checkCollisions(game.balls, game.table);
                    }

                    game.balls.forEach(b => {
                        if (b.active && b.vel.mag() > 0) moving = true;
                    });

                    if (!moving) {
                        game.handleTurnEnd();
                    }
                } else if (game.state === 'AI_THINK') {
                    AI.thinkTime++;
                    if (AI.thinkTime > 60) { // 1 second delay
                        let shot = AI.decideShot();
                        game.cueAngle = shot.angle;
                        game.cuePower = shot.power;
                        game.state = 'IDLE'; // Ready to shoot
                        game.shoot();
                    }
                }
            },

            onBallCollision: (b1, b2) => {
                if (b1.id === 0 && game.firstHit === null) {
                    game.firstHit = b2;
                }
            },

            onBallPotted: (ball) => {
                game.pottedThisTurn.push(ball);
                // Effect Visual?
            },

            handleTurnEnd: () => {
                game.state = 'IDLE';
                let cue = game.balls[0];
                let nextTurn = game.turn; // Default keep turn
                let foul = false;
                let win = false;
                let lose = false;

                // 1. Check Cue Ball Potted (Scratch)
                if (game.balls[0].potted) {
                    foul = true;
                    // Respawn Cue Ball
                    cue.active = true;
                    cue.potted = false;
                    cue.pos = new Vector(CONFIG.tableWidth/4, CONFIG.tableHeight/2);
                    cue.vel = new Vector(0,0);
                    game.ballInHand = true;
                }

                // 2. Logic Specific Rules
                if (game.gameMode === 8) {
                    // Logic 8 Ball
                    if (game.balls.find(b => b.id === 8).potted) {
                        // 8 Ball Potted
                        if (foul) {
                            lose = true; // Pot 8 on foul = Lose
                        } else {
                            // Check if groups cleared
                            let myGroup = game.assignedGroups[game.turn];
                            if (!myGroup) {
                                lose = true; // Early 8 ball
                            } else {
                                let ballsLeft = game.balls.filter(b => b.active && b.type === myGroup).length;
                                if (ballsLeft === 0) win = true;
                                else lose = true;
                            }
                        }
                    } else {
                        // Normal play
                        if (!foul) {
                            // Check Legal Hit
                            if (!game.firstHit) foul = true; // No hit
                            else {
                                // Group logic
                                if (!game.assignedGroups[game.turn]) {
                                    // Table Open
                                    if (game.pottedThisTurn.length > 0 && !game.pottedThisTurn.find(b=>b.id===8)) {
                                        // Assign Groups
                                        let firstPot = game.pottedThisTurn[0];
                                        if (firstPot.type !== 'cue') {
                                            game.assignedGroups[game.turn] = firstPot.type;
                                            game.assignedGroups[1 - game.turn] = (firstPot.type === 'solid' ? 'stripe' : 'solid');
                                        }
                                    }
                                } else {
                                    // Group Assigned
                                    if (game.firstHit.type !== game.assignedGroups[game.turn] && game.firstHit.id !== 8) {
                                        foul = true; // Wrong ball first
                                    }
                                }
                            }
                        }

                        // Turn passing
                        if (foul || game.pottedThisTurn.length === 0) {
                            nextTurn = 1 - game.turn;
                            if (foul) game.ballInHand = true;
                        } else {
                            // Potted legal ball, keep turn
                            let myGroup = game.assignedGroups[game.turn];
                            if (myGroup) {
                                let wrongPot = game.pottedThisTurn.find(b => b.type !== myGroup && b.id !== 8); // Pot opponent ball?
                                if (wrongPot) nextTurn = 1 - game.turn;
                            }
                        }
                    }
                } else {
                    // Logic 9 Ball
                    // Lowest ball must be hit first
                    let lowestId = 16;
                    game.balls.forEach(b => { if(b.active && b.id > 0 && b.id < lowestId) lowestId = b.id; });
                    
                    if (game.balls.find(b => b.id === 9).potted) {
                        if (!foul && game.firstHit && game.firstHit.id === lowestId) win = true;
                        else {
                            // 9 ball potted illegally -> Respawn 9 ball
                            let b9 = game.balls.find(b => b.id === 9);
                            b9.potted = false; 
                            b9.active = true;
                            b9.pos = new Vector(CONFIG.tableWidth * 0.75, CONFIG.tableHeight/2);
                            b9.vel = new Vector(0,0);
                            nextTurn = 1 - game.turn;
                            game.ballInHand = true;
                        }
                    } else {
                        if (!game.firstHit || game.firstHit.id !== lowestId) foul = true;
                        
                        if (foul || game.pottedThisTurn.length === 0) {
                            nextTurn = 1 - game.turn;
                            if(foul) game.ballInHand = true;
                        }
                    }
                }

                if (win) {
                    menu.endGame(true);
                } else if (lose) {
                    menu.endGame(false);
                } else {
                    game.turn = nextTurn;
                    game.updateHUD();
                    
                    if (game.turn === 1) { // AI Turn
                        game.state = 'AI_THINK';
                        AI.thinkTime = 0;
                        game.ballInHand = false; // AI places ball instantly in logic
                    }
                }
            },

            getLegalBalls: (playerIdx) => {
                if (game.gameMode === 9) {
                    let lowest = 16;
                    game.balls.forEach(b => { if(b.active && b.id > 0 && b.id < lowest) lowest = b.id; });
                    return game.balls.filter(b => b.id === lowest && b.active);
                } else {
                    let group = game.assignedGroups[playerIdx];
                    if (!group) return game.balls.filter(b => b.id !== 0 && b.id !== 8 && b.active);
                    let myBalls = game.balls.filter(b => b.type === group && b.active);
                    if (myBalls.length === 0) return game.balls.filter(b => b.id === 8); // On 8 ball
                    return myBalls;
                }
            },

            toggleCheto: () => { game.chetoMode = !game.chetoMode; },
            toggleGuideline: () => { game.extendGuide = !game.extendGuide; },
            pauseGame: () => {
                if(confirm("Keluar ke Menu Utama? Taruhan hangus.")) {
                    menu.backToMenu();
                }
            },

            updateHUD: () => {
                document.getElementById('p1-card').classList.toggle('active-turn', game.turn === 0);
                document.getElementById('p2-card').classList.toggle('active-turn', game.turn === 1);
                
                let g1 = game.assignedGroups[0] ? game.assignedGroups[0].toUpperCase() : '-';
                let g2 = game.assignedGroups[1] ? game.assignedGroups[1].toUpperCase() : '-';
                document.getElementById('p1-type').innerText = `(${g1})`;
                document.getElementById('p2-type').innerText = `(${g2})`;
            },

            loop: () => {
                game.update();
                Renderer.draw();
                requestAnimationFrame(game.loop);
            }
        };

        /**
         * ------------------------------------------------------------------
         * INPUT HANDLER
         * ------------------------------------------------------------------
         */
        const Input = {
            startX: 0, startY: 0,
            currX: 0, currY: 0,
            active: false,
            mode: 'AIM', // AIM, POWER, SPIN

            init: () => {
                let c = game.canvas;
                // Touch Events
                c.addEventListener('touchstart', Input.onStart, {passive: false});
                c.addEventListener('touchmove', Input.onMove, {passive: false});
                c.addEventListener('touchend', Input.onEnd, {passive: false});
                // Mouse Events
                c.addEventListener('mousedown', Input.onStart);
                window.addEventListener('mousemove', Input.onMove);
                window.addEventListener('mouseup', Input.onEnd);
                
                // Spin Control
                let spin = document.getElementById('spin-control');
                spin.addEventListener('touchstart', Input.onSpinStart, {passive: false});
                spin.addEventListener('touchmove', Input.onSpinMove, {passive: false});
                
                // Resize
                window.addEventListener('resize', game.resize);
                if (window.visualViewport) window.visualViewport.addEventListener('resize', game.resize);
            },

            getPos: (e) => {
                let rect = game.canvas.getBoundingClientRect();
                let clientX = e.touches ? e.touches[0].clientX : e.clientX;
                let clientY = e.touches ? e.touches[0].clientY : e.clientY;
                // Convert screen coord to logical table coord
                let x = (clientX - rect.left - game.table.x) / game.scale;
                let y = (clientY - rect.top - game.table.y) / game.scale;
                return new Vector(x, y);
            },

            onStart: (e) => {
                if (game.turn !== 0 || game.state !== 'IDLE') return;
                e.preventDefault();
                Input.active = true;
                let p = Input.getPos(e);
                Input.startX = p.x;
                Input.startY = p.y;
                Input.currX = p.x;
                Input.currY = p.y;
                
                // Check Ball in Hand
                if (game.ballInHand) {
                    let cue = game.balls[0];
                    if (p.dist(cue.pos) < CONFIG.ballRadius * 2) {
                        Input.mode = 'PLACE';
                    } else {
                        Input.mode = 'AIM';
                    }
                } else {
                    Input.mode = 'AIM';
                }
            },

            onMove: (e) => {
                if (!Input.active) return;
                e.preventDefault();
                let p = Input.getPos(e);
                Input.currX = p.x;
                Input.currY = p.y;

                if (Input.mode === 'PLACE') {
                    // Move Cue Ball
                    let cue = game.balls[0];
                    // Clamp to table
                    p.x = Math.max(game.table.rails.left, Math.min(game.table.rails.right, p.x));
                    p.y = Math.max(game.table.rails.top, Math.min(game.table.rails.bottom, p.y));
                    
                    // Simple collision check to prevent placing inside balls
                    let clear = true;
                    game.balls.forEach(b => {
                        if (b.id !== 0 && b.active && p.dist(b.pos) < b.radius * 2) clear = false;
                    });
                    
                    if(clear) cue.pos = p;
                }
                else if (Input.mode === 'AIM') {
                    // Drag logic for aiming:
                    // Calculate angle from cue ball to touch point
                    let cue = game.balls[0];
                    let dx = p.x - cue.pos.x;
                    let dy = p.y - cue.pos.y;
                    
                    // If drag far enough, update angle
                    if (Math.abs(dx) > 5 || Math.abs(dy) > 5) {
                        game.cueAngle = Math.atan2(dy, dx);
                    }
                    
                    // Power calculation (Distance dragged back)
                    // Not realistic drag-to-shoot like 8BP, simplified "Aim then Drag Power"
                    // But prompt asks for "Drag for aim and release for power"
                    // Let's use specific logic: Drag on screen rotates. 
                    // To power: we can use a separate UI or secondary drag mode.
                    // Implementation: Always aim. Use a "Power Drag" if started ON the cue ball?
                    // Let's stick to: Drag anywhere rotates cue. A separate slider appears?
                    // No, prompt says "drag to aim, release power".
                    // Let's use "Pull Back" mechanic relative to cue ball.
                    
                    let pullV = new Vector(dx, dy);
                    let dist = pullV.mag();
                    
                    // Angle is opposite to pull
                    game.cueAngle = Math.atan2(-dy, -dx);
                    
                    // Power based on distance
                    let power = Math.min(dist / 5, CONFIG.maxPower); // 200px drag = max
                    game.cuePower = power;
                    
                    // Update UI Bar
                    let bar = document.getElementById('power-container');
                    let fill = document.getElementById('power-fill');
                    bar.style.display = 'block';
                    fill.style.height = (power / CONFIG.maxPower * 100) + '%';
                }
            },

            onEnd: (e) => {
                if (!Input.active) return;
                Input.active = false;
                
                if (Input.mode === 'PLACE') {
                    game.ballInHand = false;
                } else if (Input.mode === 'AIM') {
                    if (game.cuePower > 2) { // Minimum power threshold
                        game.shoot();
                    }
                }
                game.cuePower = 0;
            },
            
            onSpinStart: (e) => { e.stopPropagation(); },
            onSpinMove: (e) => {
                e.preventDefault(); e.stopPropagation();
                let touch = e.touches[0];
                let rect = e.target.closest('#spin-control').getBoundingClientRect();
                let cx = rect.left + rect.width/2;
                let cy = rect.top + rect.height/2;
                let dx = (touch.clientX - cx) / (rect.width/2);
                let dy = (touch.clientY - cy) / (rect.height/2);
                
                // Clamp circle
                let dist = Math.sqrt(dx*dx + dy*dy);
                if (dist > 1) { dx/=dist; dy/=dist; }
                
                game.spinOffset = new Vector(dx, dy);
                
                let dot = document.getElementById('spin-dot');
                dot.style.transform = `translate(-50%, -50%) translate(${dx*35}px, ${dy*35}px)`;
            }
        };

        /**
         * ------------------------------------------------------------------
         * RENDERER
         * ------------------------------------------------------------------
         */
        const Renderer = {
            draw: () => {
                let ctx = game.ctx;
                ctx.clearRect(0, 0, game.width, game.height);
                
                ctx.save();
                // Apply table transform
                ctx.translate(game.table.x, game.table.y);
                ctx.scale(game.scale, game.scale);
                
                // Draw Table
                Renderer.drawTable(ctx);
                
                // Draw Guidelines (Layer Under Balls)
                if (game.state === 'IDLE' && game.turn === 0 && !game.ballInHand) {
                    Renderer.drawGuideline(ctx);
                }

                // Draw Balls
                // Sort by Y to fake depth? 2D top down, not needed really.
                game.balls.forEach(b => Renderer.drawBall(ctx, b));

                // Draw Cue Stick
                if (game.state === 'IDLE' && !game.ballInHand && game.turn === 0) {
                    Renderer.drawCue(ctx);
                }

                ctx.restore();
            },

            drawTable: (ctx) => {
                let w = CONFIG.tableWidth;
                let h = CONFIG.tableHeight;
                
                // Wood Frame
                ctx.fillStyle = '#4e342e';
                ctx.fillRect(-20, -20, w+40, h+40);
                
                // Felt
                ctx.fillStyle = '#0a6c03'; // Classic Green
                ctx.fillRect(0, 0, w, h);
                
                // Playable Area Outline
                ctx.strokeStyle = '#0d8505';
                ctx.lineWidth = 2;
                ctx.strokeRect(game.table.rails.left, game.table.rails.top, 
                               game.table.rails.right-game.table.rails.left, 
                               game.table.rails.bottom-game.table.rails.top);

                // Pockets
                ctx.fillStyle = '#000';
                game.table.pockets.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, CONFIG.pocketRadius, 0, Math.PI*2);
                    ctx.fill();
                    // Metallic Rim
                    ctx.strokeStyle = '#666';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                });
            },

            drawBall: (ctx, b) => {
                if (!b.active) return;
                
                ctx.beginPath();
                ctx.arc(b.pos.x, b.pos.y, b.radius, 0, Math.PI*2);
                ctx.fillStyle = b.color;
                ctx.fill();
                
                // Shading (Simple specular)
                let grad = ctx.createRadialGradient(b.pos.x - 4, b.pos.y - 4, 1, b.pos.x, b.pos.y, b.radius);
                grad.addColorStop(0, 'rgba(255,255,255,0.3)');
                grad.addColorStop(1, 'rgba(0,0,0,0.1)');
                ctx.fillStyle = grad;
                ctx.fill();

                // Stripe
                if (b.type === 'stripe' || (b.id > 8 && b.id < 16)) {
                    ctx.fillStyle = '#fff';
                    ctx.beginPath();
                    ctx.arc(b.pos.x, b.pos.y, b.radius * 0.7, 0, Math.PI*2); // Center white circle for stripe look
                    // Actually stripe usually is a band. Let's keep it simple: number circle
                }

                // Number Circle
                if (b.id !== 0) {
                    ctx.fillStyle = 'rgba(255,255,255,0.8)';
                    ctx.beginPath();
                    ctx.arc(b.pos.x, b.pos.y, b.radius * 0.4, 0, Math.PI*2);
                    ctx.fill();
                    
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(b.id, b.pos.x, b.pos.y);
                }
            },

            drawCue: (ctx) => {
                let cueBall = game.balls[0];
                let len = 300;
                
                ctx.save();
                ctx.translate(cueBall.pos.x, cueBall.pos.y);
                ctx.rotate(game.cueAngle);
                
                // Stick offset (pull back animation)
                let offset = 20 + game.cuePower * 2;
                
                // Stick
                ctx.translate(-offset, 0);
                
                // Stick Design
                ctx.fillStyle = '#8b5a2b';
                ctx.fillRect(-len, -3, len, 6);
                ctx.fillStyle = '#d2b48c';
                ctx.fillRect(-100, -3, 10, 6); // Detail
                
                // Tip
                ctx.fillStyle = '#00f'; // Blue chalk
                ctx.fillRect(0, -3, 5, 6);
                
                ctx.restore();
            },

            drawGuideline: (ctx) => {
                let cue = game.balls[0];
                
                // Simulation for guideline
                // Copy state
                let simBalls = game.balls.map(b => {
                    let nb = new Ball(b.id, b.pos.x, b.pos.y, b.type);
                    nb.active = b.active;
                    return nb;
                });
                let simCue = simBalls[0];
                
                // Set velocity based on current power/aim
                // Default minimum visualization
                let power = Math.max(game.cuePower, 15); 
                simCue.vel = new Vector(Math.cos(game.cueAngle)*power, Math.sin(game.cueAngle)*power);

                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                
                // Path Tracking
                let path = [{x: simCue.pos.x, y: simCue.pos.y}];
                let steps = game.chetoMode ? 1200 : (game.extendGuide ? 600 : 200);
                
                let firstHitBall = null;

                for(let i=0; i<steps; i++) {
                    simBalls.forEach(b => b.update());
                    let collision = Physics.checkCollisions(simBalls, game.table, true);
                    
                    // Simple logic: if collision with ball, stop standard guideline
                    // If Cheto, continue
                    if (!game.chetoMode && !game.extendGuide && collision) break;
                    
                    path.push({x: simCue.pos.x, y: simCue.pos.y});
                    
                    // Ghost ball render when hit object ball
                    // Complex to detect exact frame of ball-ball collision here cleanly without event
                    // But we can draw path.
                }

                // Draw Path
                ctx.moveTo(path[0].x, path[0].y);
                for(let i=1; i<path.length; i++) ctx.lineTo(path[i].x, path[i].y);
                ctx.stroke();

                // Ghost Ball (End of path or First Hit approximation)
                if (game.chetoMode) {
                    let end = path[path.length-1];
                    ctx.beginPath();
                    ctx.arc(end.x, end.y, CONFIG.ballRadius, 0, Math.PI*2);
                    ctx.strokeStyle = 'cyan';
                    ctx.setLineDash([]);
                    ctx.stroke();
                }

                ctx.restore();
            }
        };

        /**
         * ------------------------------------------------------------------
         * MENU & ECONOMY SYSTEM
         * ------------------------------------------------------------------
         */
        const menu = {
            balance: 1000,
            currentBet: 0,

            updateUI: () => {
                document.getElementById('user-balance').innerText = menu.balance.toLocaleString();
            },

            selectMode: (m) => {
                game.gameMode = m;
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('selected'));
                event.target.classList.add('selected');
            },

            enterRoom: (amount) => {
                if (menu.balance < amount) {
                    alert("Saldo tidak cukup!");
                    return;
                }
                menu.balance -= amount;
                menu.currentBet = amount;
                localStorage.setItem('billiard_balance', menu.balance);
                
                document.getElementById('pot-amount').innerText = (amount * 2).toLocaleString();
                game.startMatch(game.gameMode, amount);
            },

            endGame: (win) => {
                let modal = document.getElementById('result-modal');
                let title = document.getElementById('result-text');
                let prize = document.getElementById('result-prize');
                
                modal.style.display = 'flex';
                
                if (win) {
                    title.innerText = "YOU WIN!";
                    title.className = "result-title win";
                    let winnings = menu.currentBet * 2;
                    menu.balance += winnings;
                    prize.innerText = "Prize: " + winnings.toLocaleString();
                } else {
                    title.innerText = "YOU LOSE";
                    title.className = "result-title lose";
                    prize.innerText = "Better luck next time";
                }
                
                localStorage.setItem('billiard_balance', menu.balance);
            },

            backToMenu: () => {
                document.getElementById('result-modal').style.display = 'none';
                document.getElementById('game-ui').classList.add('hidden');
                document.getElementById('main-menu').classList.remove('hidden');
                game.state = 'MENU';
                menu.updateUI();
            }
        };

        // --- BOOTSTRAP ---
        window.onload = game.init;

    </script>
</body>
</html>
